/*
			__      ________     __       __
 __        /\ \    /\_____  \  /'_ `\   /'__`\
/\_\    ___\ \ \/'\\/____//'/'/\ \L\ \ /\ \/\ \
\/\ \ /' _ `\ \ , <     //'/' \/_> _ <_\ \ \ \ \
 \ \ \/\ \/\ \ \ \\`\  //'/'___ /\ \L\ \\ \ \_\ \
  \ \_\ \_\ \_\ \_\ \_\/\_______\ \____/ \ \____/
   \/_/\/_/\/_/\/_/\/_/\/_______/\/___/   \/___/

*/
/////////////////////////////////////////////////////////////////////////////
// Name:        inkz80.cpp
// Purpose:     InkZ80 Z80 Emulator
// Author:      Mark Incley
// Created:     30/10/2007
// Copyright:   Mark Incley
// Licence:     OpenSource
/////////////////////////////////////////////////////////////////////////////


#include <stdlib.h>
#include <assert.h>
#include <algorithm>

#include "inkz80.h"
#include "inkz80core.h"

// Tables generated by maketab.lua
#include "tables.cpp"


static const std::string InkZ80VersionStr = "InkZ80 0.17";


// The following two functions burn an addition number of t-states during opcode processing.
// The functions are virtual so that systems such as ZX Spectrum may calculate additional ts that
// need to be consumed due to memory contention.

inline void Z80::applyMemoryContention(int ts, WORD addr)
{
	assert(ts >= 0 && ts <= 7);	// To trap any addresses incorrectly passed as the first parameter!
	burnTS(ts);
}


inline void Z80::applyMemoryContentionCompound(int ts, WORD addr)
{
	assert(ts >= 0 && ts <= 7);	// To trap any addresses incorrectly passed as the first parameter!
	burnTS(ts);
}


Z80::Z80() :
	_busValue(255),
	_TStateCount(0),
	_TStateCountUntil(0),
	_TStateCountAtStart(0),
	_numInstructionsExecuted(0),
	_opCBDisplacement(0),
	_newModifiedFlags(false),
	_RCountRemaining(0),
	m_executionState(XSExhaustedTStates),
	m_breakpointTypeHit(BreakpointNone),
	m_breakpointIdHit(BreakpointIdNone),
	m_breakpointIdSeed(1)
{
	DeleteAllBreakpoints(true);
	powerOn();
}


Z80::~Z80()
{
}


//
// Register getters
//
BYTE Z80::getRegisterI() const					{return I;}
BYTE Z80::getRegisterR() const					{return (R & 0x7f) | (R2 & 0x80);}
WORD Z80::getRegisterAF() const					{return AF;}
WORD Z80::getRegisterBC() const					{return BC;}
WORD Z80::getRegisterDE() const					{return DE;}
WORD Z80::getRegisterHL() const					{return HL;}
WORD Z80::getRegisterIX() const					{return IX;}
WORD Z80::getRegisterIY() const					{return IY;}
WORD Z80::getRegisterAFAlt() const				{return AF_ALT;}
WORD Z80::getRegisterBCAlt() const				{return BC_ALT;}
WORD Z80::getRegisterDEAlt() const				{return DE_ALT;}
WORD Z80::getRegisterHLAlt() const				{return HL_ALT;}
WORD Z80::getRegisterSP() const					{return SP;}
WORD Z80::getRegisterPC() const					{return PC;}
WORD Z80::getRegisterWZ() const					{return WZ;}

//
// Register setters
//
void Z80::setRegisterI(const BYTE i)			{I = i;}
void Z80::setRegisterR(const BYTE r)			{R = R2 = r;}
void Z80::setRegisterAF(const WORD af)			{AF = af;}
void Z80::setRegisterBC(const WORD bc)			{BC = bc;}
void Z80::setRegisterDE(const WORD de)			{DE = de;}
void Z80::setRegisterHL(const WORD hl)			{HL = hl;}
void Z80::setRegisterIX(const WORD ix)			{IX = ix;}
void Z80::setRegisterIY(const WORD iy)			{IY = iy;}
void Z80::setRegisterAFAlt(const WORD afAlt)	{AF_ALT = afAlt;}
void Z80::setRegisterBCAlt(const WORD bcAlt)	{BC_ALT = bcAlt;}
void Z80::setRegisterDEAlt(const WORD deAlt)	{DE_ALT = deAlt;}
void Z80::setRegisterHLAlt(const WORD hlAlt)	{HL_ALT = hlAlt;}
void Z80::setRegisterSP(const WORD sp)			{SP = sp;}
void Z80::setRegisterPC(const WORD pc)			{PC = pc;}
void Z80::setRegisterWZ(const WORD wz)			{WZ = wz;}

void Z80::setIFF1(const FlipFlop iff1)
{
	if (iff1 == FlipFlopReset || iff1 == FlipFlopSet)
		_iff1 = iff1;
}


void Z80::setIFF2(const FlipFlop iff2)
{
	if (iff2 == FlipFlopReset || iff2 == FlipFlopSet)
		_iff2 = iff2;
}


bool Z80::isFlagSet(Flag flag) const
{
	return (F & (1 << flag)) != 0;
}


bool Z80::isAltFlagSet(Flag flag) const
{
	return (F_ALT & (1 << flag)) != 0;
}


void Z80::setFlag(Flag flag, bool set)
{
	BYTE mask = 1 << flag;
	if (set)
		F |= mask;
	else
		F &= ~mask;
}


void Z80::setAltFlag(Flag flag, bool set)
{
	BYTE mask = 1 << flag;
	if (set)
		F_ALT |= mask;
	else
		F_ALT &= ~mask;
}


void Z80::powerOn()
{
	// Set registers to 0xffff before applying the known reset values
	BC = DE = HL = AF_ALT = BC_ALT = DE_ALT = HL_ALT = IX = IY = WZ = 0xffff;
	reset();
}


void Z80::reset()
{
	// PC always 0
	setRegisterPC(0);
	// IR = 0
	setRegisterI(0);
	setRegisterR(0);
	// SP and AF are set to 0xFFFF on a reset
	setRegisterAF(0xffff);
	setRegisterSP(0xffff);
	_lastInstructionModifiedFlags = false;
	// IM0
	setInterruptMode(IM0);
	// With interrupts disabled
	IFF1 = IFF2 = FlipFlopReset;
	_NMIPending = false;
	_NMILine = LineHigh;			// No NMIs pending
	_INTLine = LineHigh;			// No maskable ints pending
	_M1Line = LineHigh;				
	_MREQLine = LineHigh;
	_IORQLine = LineHigh;
	_RDLine = LineHigh;
	_WRLine = LineHigh;
	setPostEI(false);
	setHalted(false);
	_ddfdPrefix = PrefixNone;
}


void Z80::setNMILine(const LineState lineState)
{
	if (lineState == LineLow || lineState == LineHigh)
	{
		// NMI is edge triggered - i.e. when the NMI line goes from high to low
		if ((_NMILine == LineHigh) && lineState == LineLow)
			_NMIPending = true;
		_NMILine = lineState;
	}
}


void Z80::setINTLine(const LineState lineState)
{
	if (lineState == LineLow || lineState == LineHigh)
	{
		_INTLine = lineState;
	}
}


void Z80::setHalted(const bool halted)
{
	_HALTLine = halted ? LineLow : LineHigh;
	_isHalted = halted;
}


void Z80::setPostEI(const bool postEI)
{
	_postEI = postEI;
}


void Z80::setInterruptMode(const InterruptMode im)
{
	if (im == IM0 || im == IM1 || im == IM2)
		_interruptMode = im;
}


unsigned Z80::getElapsedTStates() const
{
	return _TStateCount - _TStateCountAtStart;
}


bool Z80::isINTPending() const
{
	if ((_INTLine == LineLow) && (IFF1 == FlipFlopSet) && (_ddfdPrefix == PrefixNone) && (isPostEI() == false))
		return true;

	return false;
}


bool Z80::isNMIPending() const
{
	// [TODO: Confirm whether the Z80 accepts NMI if it's in the middle of DD/FD instruction?]
	//		i.e. should DD/FD cause NMI reqs to be ignored as they do for maskable ints?
	return (_NMIPending && (_ddfdPrefix == PrefixNone));
}


WORD Z80::getINTVector() const
{
	WORD vec;
	switch(_interruptMode)
	{
	case IM0:
		vec = 0x38;		// TODO: Use opcode of _busValue?
		break;

	case IM1:
		vec = 0x38;
		break;

	case IM2:
		vec = _busValue + 256 * I;
		break;

	default:            // To suppress gcc release build warning
		vec = 0;
		break;
	}
	return vec;
}


void Z80::UnHalt()
{
	if (_isHalted)
	{
		PC++;
		_isHalted = false;
		_HALTLine = LineHigh;
	}
}


bool Z80::checkIRQ()
{
	bool accepted = false;

	if (isNMIPending())
	{
		// Zilog docs claim a memory read which is ignored!
		
		// Acknowledge the NMI
		acknowledgeNMI();

		// Contrary to the Zilog documentation, IFF1 is not copied to IFF2
		IFF1 = FlipFlopReset;		// Maskable interrupts off while we service the NMI
		R++;						// Accepting an NMI increments R

		// If we're halted, skip past the HALT instruction
		// NB PC is increased before any interrupt function is called
		UnHalt();

		// From http://www.z80.info/interrup.htm
		// It takes 11 clock cycles to get to #0066:
		// M1 cycle: 5 T states to do an opcode read and decrement SP
		// M2 cycle: 3 T states write high byte of PC to the stack and decrement SP
		// M3 cycle: 3 T states write the low byte of PC and jump to #0066.
		burnTS(5);					// M1 cycle
		Push(PC);					// M2 and M3 cycles, totalling 11ts
		PC = 0x66;
		accepted = true;
		_NMIPending = false;

		OnNMITaken();
	}

	// Only accept maskable interrupts if they're enabled and we're not in the middle of an IX/IY instruction
	if ((accepted == false) && isINTPending())
	{
		//
		// INT accepted. This is going to cost 13ts (IM0 and IM1) or 19ts (IM2)
		//

		// M1 line goes low during interrupt acknowledgement
		// IORQ line goes low during interrupt acknowledgement
		_M1Line = _IORQLine = LineLow;
		
		// Call any registered INT acknowledge handler
		_busValue = 0xff;
		acknowledgeINT(_busValue);
		
		// End of int ack
		// done here. In IM0 or IM2 a normal memory read is triggered.
		_M1Line = _IORQLine = LineHigh;
		
		// Accepting an interrupt increments R
		// Note that Sinclair ZX Spectrum RZX playback doesn't count int ack as an R change
		// which is why we're using R++ rather than IncR()
		R++;

		// If we're halted, skip past the HALT instruction
		// NB PC is increased before any interrupt function is called
		UnHalt();

		// Interrupts off so we don't end up with nested interrupts
		IFF1 = IFF2 = FlipFlopReset;

		// TODO: Currently IM0 behaves as IM1
		if (_interruptMode == IM0)
		{
			burnTS(7);				// M1: acknowledge INT and decrement SP
			Push(PC);				// M2 and M3: write PC on the stack. Total 13ts
			PC = getINTVector();	// TODO: execute opcode of _busValue?
		}
		else if (_interruptMode == IM1)
		{
			burnTS(7);				// M1: acknowledge INT and decrement SP
			Push(PC);				// M2 and M3: write PC on the stack. Total 13ts
			PC = getINTVector();
		}
		else if (_interruptMode == IM2)
		{
			burnTS(7);				// M1: acknowledge INT and decrement SP
			Push(PC);				// M2 and M3: 6ts to write PC on the stack
			WORD addr = getINTVector();
			PC = ReadWord(addr);	// M4 and M5: 6ts to read interrupt address from vector, totalling 19ts
		}
		else
		{
			// Unknown interrupt mode
			assert(false);
		}

		OnIntTaken();

		accepted = true;
	}
	return accepted;
}


inline void Z80::discardByte()
{
	applyMemoryContention(3, PC++);
}


inline void Z80::discardWord()
{
	discardByte();
	discardByte();
}


inline BYTE Z80::ReadOpCode()
{
	_M1Line = _MREQLine = LineLow;
	
	applyMemoryContention(4, PC);		// M1 cycle burns minimum of 4 TS
	BYTE b = memoryReadRaw(PC++);

	 _M1Line = _MREQLine = LineHigh;
	IncR();
	return b;
}


inline BYTE Z80::ReadByte()
{
	_MREQLine = _RDLine = LineLow;
	applyMemoryContention(3, PC);
	BYTE b = memoryReadRaw(PC++);
	_MREQLine = _RDLine = LineHigh;
	return b;
}


inline BYTE Z80::ReadByte(WORD addr)
{
	_MREQLine = _RDLine = LineLow;
	applyMemoryContention(3, addr);
	BYTE b = memoryReadRaw(addr);
	_MREQLine = _RDLine = LineHigh;

	TestHitBreakpoint(BreakpointMemoryRead, addr);

	return b;
}


inline WORD Z80::ReadWord()
{
	return ReadByte() + 256 * ReadByte();
}


inline WORD Z80::ReadWord(WORD addr)
{
	return ReadByte(addr) + 256 * ReadByte(addr+1);
}


inline void Z80::WriteByte(WORD addr, BYTE val)
{
	_MREQLine = _WRLine = LineLow;
	applyMemoryContention(3, addr);
	memoryWriteRaw(addr, val);
	_MREQLine = _WRLine = LineHigh;

	TestHitBreakpoint(BreakpointMemoryWrite, addr);
}


inline void Z80::WriteWord(WORD addr, WORD val)
{
	WriteByte(addr, val & 0xff);
	WriteByte(addr+1, val >> 8);
}


inline BYTE Z80::ReadPort(WORD port)
{
	_IORQLine = _RDLine = LineLow;
	TestHitBreakpoint(BreakpointPortRead, port);

	//
	// NB the client must consume at least 4ts here by calling BurnTS().
	// This is done to allow emulation of systems such as the ZX Spectrum to implement
	// I/O contention where the hardware may hold back the Z80 for a longer period.
	//
	BYTE data = portRead(port);
	
	_IORQLine = _RDLine = LineHigh;
	return data;
}


inline void Z80::WritePort(WORD port, BYTE val)
{
	_IORQLine = _WRLine = LineLow;
	TestHitBreakpoint(BreakpointPortWrite, port);

	//
	// See comment for ReadPort() above
	//
	portWrite(port, val);
	_IORQLine = _WRLine = LineHigh;
}


void Z80::RequestEndExecution()
{
	m_enabledBreakpointTypeBitmap |= BreakpointExitExecution;
}


TStates Z80::executeSingleInstruction()
{
	return executeTStates(1);
}


TStates Z80::executeTStates(const TStates ts)
{
	// Check for tstate count wrap-around
	if ((_TStateCount + ts) < _TStateCount)
		_TStateCount = 0;

	_TStateCountAtStart = _TStateCount;
	_TStateCountUntil = _TStateCount + ts;
	return ExecuteResume();
}


TStates Z80::ExecuteResume()
{
	m_breakpointIdHit = BreakpointIdNone;
	m_breakpointTypeHit = BreakpointNone;
	m_executionState = XSRunning;
	ExecutionState xs = XSExhaustedTStates;
	unsigned numDDFD = 0;		// instruction count

	// The request to exit execution is one-shot
	m_enabledBreakpointTypeBitmap &= ~BreakpointExitExecution;

	// We test numDDFD so that if some comedian ever executes 64K's worth of DD/FDs,
	// then InkZ80 won't get stuck in an infinite loop waiting for _ddfdPrefix to clear.
	while (m_executionState == XSRunning && (_TStateCount < _TStateCountUntil || (_ddfdPrefix != PrefixNone)) && (numDDFD < AddressableMemorySize))
	{
		// Save some time by only checking when we know we have some breakpoints
		// NB we only check when we're not in the middle of a DD/FD instruction
		if (m_enabledBreakpointTypeBitmap && (_ddfdPrefix == PrefixNone))
		{
			// Have we been asked to exit?
			if (m_enabledBreakpointTypeBitmap & BreakpointExitExecution)
			{
				m_executionState = XSExitRequested;
				break;
			}

			// DI / HALT combo?
			if (isHalted() && IFF1 == FlipFlopReset)
			{
				if (TestHitBreakpoint(BreakpointDIHalt))
					break;
			}

			// R-register countdown
			if (_RCountRemaining <= 0)
			{
				if (TestHitBreakpoint(BreakpointRCountdown))
					break;
			}

			// Execute instruction?
			if (TestHitBreakpoint(BreakpointOpcodeRead, PC))
				break;
		}

		// Check for a pending maskable interrupt or NMI
		if (checkIRQ())
		{
			if (TestHitBreakpoint(BreakpointIntAccepted))
				break;
		}

		ExecuteInstruction();

		// And increment number of DD/FD instructions processed
		numDDFD = _ddfdPrefix == PrefixNone ? 0 : numDDFD + 1;

		// Increase the count of instructions executed
		_numInstructionsExecuted++;
	}

	// Don't perform this test if we've hit a breakpoint
	if (m_executionState == XSRunning)
	{
		// Did we encounter an entire memory full of DD/FDs?
		if (numDDFD >= AddressableMemorySize)
			xs = XSInfiniteDDFDLoop;

		m_executionState = xs;
	}

	return getElapsedTStates();
}


//
// Start of Z80 emulation
//

inline BYTE Z80::CalcFlagH(const WORD result, const BYTE op1, const BYTE op2)
{
	return (result ^ op1 ^ op2) & FLAG_H;
}


inline BYTE Z80::CalcFlagVAdd(const WORD result, const BYTE op1, const BYTE op2)
{
	return ((~(op1 ^ op2) & (op1 ^ result)) >> 5) & FLAG_V;
}


inline BYTE Z80::CalcFlagVSub(const WORD result, const BYTE op1, const BYTE op2)
{
	return (((op1 ^ op2) & (op1 ^ result)) >> 5) & FLAG_V;
}


inline BYTE Z80::CalcFlagH(const DWORD result, const WORD op1, const WORD op2)
{
	return ((result ^ op1 ^ op2) >> 8) & FLAG_H;
}


inline BYTE Z80::CalcFlagVAdd(const DWORD result, const WORD op1, const WORD op2)
{
	return ((~(op1 ^ op2) & (op1 ^ result)) >> 13) & FLAG_V;
}


inline BYTE Z80::CalcFlagVSub(const DWORD result, const WORD op1, const WORD op2)
{
	return (((op1 ^ op2) & (op1 ^ result)) >> 13) & FLAG_V;
}


inline void Z80::IncR()
{
	R++;
	_RCountRemaining--;
}


inline void Z80::SetF(BYTE f)
{
	F = f;
	_newModifiedFlags = true;
}


inline void Z80::AddHL(WORD val16)
{
	DWORD result;
	WORD dst = HLIXIY;
	WZ = dst + 1;
	result = dst + val16;
	SetF((F & (FLAG_S | FLAG_Z | FLAG_V)) |
		((result >> 8) & FLAGS_35) |
		(((dst ^ result ^ val16) >> 8) & FLAG_H) |
		((result >> 16) & FLAG_C));
	HLIXIY = (WORD)result;
}


inline void Z80::AdcHL(WORD val16)
{
	WORD dst = HLIXIY;
	WZ = dst + 1;
	DWORD result = dst + val16 + (F & FLAG_C);
	SetF(((result >> 8) & (FLAG_S | FLAGS_35)) |		// S35
		CalcFlagH(result, dst, val16) |					// H
		((result >> 16) & FLAG_C) |						// C
		((result & 0xffff) == 0 ? FLAG_Z : 0) |			// Z
		CalcFlagVAdd(result, dst, val16));  			// V
	HLIXIY = (WORD)result;
	applyMemoryContentionCompound(4 + 3, IR);			// M3 = 4, M4 = 3
}


inline void Z80::SbcHL(WORD val16)
{
	WORD dst = HLIXIY;
	WZ = dst + 1;
	DWORD result = dst - val16 - (F & FLAG_C);
	SetF(((result >> 8) & (FLAG_S | FLAGS_35)) |
		CalcFlagH(result, dst, val16) |
		((result >> 16) & FLAG_C) |
		((result & 0xffff) == 0 ? FLAG_Z : 0 ) |
		CalcFlagVSub(result, dst, val16) |
		FLAG_N);
	HLIXIY = (WORD)result;
	applyMemoryContentionCompound(4 + 3, IR);		// M3 = 4, M4 = 3
}


inline WORD Z80::GetEA()
{
	WORD ea = HLIXIY;
	// If there's no DD/FD prefix, return HL without modifying WZ
	if (_ddfdPrefix != PrefixNone)
	{
		SBYTE disp = ReadByte();
		applyMemoryContentionCompound(5, PC-1);
		ea += disp;
		WZ = ea;
	}
	return ea;
}


inline void Z80::GetEAImm(WORD & addr, BYTE & val)
{
	addr = HLIXIY;
	// DD or FD prefix active?
	if (_ddfdPrefix != PrefixNone)
	{
		SBYTE disp = ReadByte();
		val = ReadByte();
		applyMemoryContentionCompound(2, PC-1);
		addr += disp;
		WZ = addr;
	}
	else
	{
		val = ReadByte();
	}
}


inline void Z80::Jr()
{
	SBYTE disp = ReadByte();
	applyMemoryContentionCompound(5, PC-1);		// M3 = 5 (-1 because need to contend on PC)
	PC += disp;
	WZ = PC;
}


inline void Z80::Jr(bool conditionMet)
{
	if (conditionMet)
		Jr();
	else
		discardByte();
}


inline void Z80::Jp()
{
	PC = ReadWord();
	WZ = PC;
}


inline void Z80::Jp(bool conditionMet)
{
	if (conditionMet)
		Jp();
	else
		discardWord();					// Discard address
}


inline void Z80::Call()
{
	WORD addr = ReadWord();
	applyMemoryContention(1, PC-1);		// M3 = 4
	Push(PC);
	PC = addr;
	WZ = addr;
	return;
}


inline void Z80::Call(bool conditionMet)
{
	if (conditionMet)
		Call();
	else
		discardWord();					// Discard call address
	return;
}


inline void Z80::Rst(WORD addr)
{
	applyMemoryContention(1, IR);		// M1 = 5
	Push(PC);
	PC = addr;
	WZ = addr;
	return;
}


inline void Z80::Ret()
{
	PC = Pop();
	WZ = PC;
}


inline void Z80::Ret(bool conditionMet)
{
	applyMemoryContention(1, IR);		// M1 = 5
	if (conditionMet)
		Ret();
}


inline void Z80::Neg()
{
	BYTE val = A;
	A = 0;
	Sub(val);
}


inline void Z80::Dec(BYTE & r)
{
	r--;
	SetF((F & FLAG_C) | tableZSHV35_DEC8[r]);
}


inline void Z80::Inc(BYTE & r)
{
	r++;
	SetF((F & FLAG_C) | tableZSHV35_INC8[r]);
}


inline void Z80::Sub(BYTE value)
{
	WORD result = A - value;
	SetF(tableZS35[result & 0xff] |			// ZS35
		FLAG_N |							// N
		((result >> 8) & FLAG_C) |			// C
		CalcFlagH(result, A, value) |		// H
		CalcFlagVSub(result, A, value));	// V
	A = (BYTE)result;
}


inline void Z80::Sbc(BYTE value)
{
	WORD result = A - value - (F & FLAG_C);
	SetF(tableZS35[result &0xff] |			// ZS35
		FLAG_N |							// N
		((result >> 8) & FLAG_C) |			// C
		CalcFlagVSub(result, A, value) |	// V
		CalcFlagH(result, A, value));		// H
	A = (BYTE)result;
}


inline void Z80::Cp(BYTE value)
{
	WORD result = A - value;
	SetF(tableZS[result & 0xff] |			// ZS
		(value & FLAGS_35) |				// 35
		FLAG_N |							// N
		((result >> 8) & FLAG_C) |			// C
		CalcFlagVSub(result, A, value) |	// V
		CalcFlagH(result, A, value));		// H
}


inline void Z80::Add(BYTE value)
{
	WORD result = A + value;
	SetF(tableZS35[result & 0xff] |			// ZS35
		((result >> 8) & FLAG_C) |			// C
		CalcFlagVAdd(result, A, value) |	// V
		CalcFlagH(result, A, value));		// H
	A = (BYTE)result;
}


inline void Z80::Adc(BYTE value)
{
	WORD result = A + value + (F & FLAG_C);
	SetF(tableZS35[result & 0xff] |			// Set ZS35
		((result >> 8) & FLAG_C) |			// C
		CalcFlagVAdd(result, A, value) |	// V
		CalcFlagH(result, A, value));		// H
	A = (BYTE)result;
}


inline void Z80::And(BYTE value)
{
	A &= value;
	SetF(tableZS35P[A] | FLAG_H);
}


inline void Z80::Xor(BYTE value)
{
	A ^= value;
	SetF(tableZS35P[A]);
}


inline void Z80::Or(BYTE value)
{
	A |= value;
	SetF(tableZS35P[A]);
}


// The Z80 PIO can distinguish between reti and retn by looking at the instruction directly
// on the Z80's data bus, but as far as we're concerned, they're exactly the same.
// The only reason to have separate functions is to call the OnRetiExit() function.
inline void Z80::Retn()
{
	PC = Pop();
	WZ = PC;
	IFF1 = IFF2;
}


inline void Z80::Reti()
{
	PC = Pop();
	WZ = PC;
	IFF1 = IFF2;

	OnExitReti();
}


inline void Z80::Im0()
{
	setInterruptMode(IM0);
}


inline void Z80::Im1()
{
	setInterruptMode(IM1);
}


inline void Z80::Im2()
{
	setInterruptMode(IM2);
}


inline void Z80::LdIA()
{
	applyMemoryContention(1, IR);		// M2 = 5
	I = A;
}


inline void Z80::LdRA()
{
	applyMemoryContention(1, IR);		// M2 = 5
	R = R2 = A;
}


inline void Z80::LdAI()
{
	applyMemoryContention(1, IR);		// M2 = 5
	A = I;
	SetF((F & FLAG_C) | tableZS35[A] | (IFF2 == FlipFlopReset ? 0 : FLAG_P));
}


inline void Z80::LdAR()
{
	applyMemoryContention(1, IR);		// M2 = 5
	A = getRegisterR();
	SetF((F & FLAG_C) | tableZS35[A] | (IFF2 == FlipFlopReset ? 0 : FLAG_P));
}


inline void Z80::Rld()
{
	BYTE mem = ReadByte(HL);
	applyMemoryContentionCompound(4, HL);
	BYTE mem2 = mem;
	mem = (mem << 4) | (A & 0x0f);
	WriteByte(HL, mem);
	A = (A & 0xf0) | (mem2 >> 4);
	SetF(tableZS35P[A] | (F & FLAG_C));
	WZ = HL + 1;
}


inline void Z80::Rrd()
{
	BYTE mem = ReadByte(HL);
	applyMemoryContentionCompound(4, HL);
	BYTE mem2 = mem;
	mem = (mem >> 4) | (A << 4);
	WriteByte(HL, mem);
	A = (A & 0xf0) | (mem2 & 0x0f);
	SetF(tableZS35P[A] | (F & FLAG_C));
	WZ = HL + 1;
}


//
// ED instructions
//

inline void Z80::LdNNRR(WORD & r16)
{
	WORD addr = ReadWord();
	WZ = addr + 1;
	WriteWord(addr, r16);
}


inline void Z80::LdRRNN(WORD & r16)
{
	WORD addr = ReadWord();
	WZ = addr + 1;
	r16 = ReadWord(addr);
}


inline void Z80::InC(BYTE & r)
{
	r = ReadPort(BC);
	WZ = BC + 1;
	SetF(tableZS35P[r] | (F & FLAG_C));
}


inline void Z80::InCF()
{
	BYTE discardedResult;
	InC(discardedResult);
}


inline void Z80::OutC(BYTE r)
{
	WZ = BC + 1;
	WritePort(BC, r);
}


inline void Z80::Ldi()
{
	BYTE val8 = ReadByte(HL++);
	WriteByte(DE, val8);
	applyMemoryContentionCompound(2, DE);
	DE++;
	BC--;
	val8 += A;
	SetF((F & (FLAG_S | FLAG_Z | FLAG_C)) | (BC != 0 ? FLAG_P : 0) | ((val8 & FLAG_BIT3) | ((val8 << 4) & FLAG_BIT5)));
}


inline void Z80::Cpi()
{
	BYTE val8 = ReadByte(HL);
	applyMemoryContentionCompound(5, HL);
	HL++;
	BC--;
	BYTE result = A - val8;
	SetF(tableZS[result] |					// ZS
		(F & FLAG_C) |						// Leave C alone
		FLAG_N |							// N
		CalcFlagH(result, A, val8) |		// H
		(BC != 0 ? FLAG_P : 0));			// P
	result -= ((F & FLAG_H) >> 4);
	F |= ((result & FLAG_BIT3) | ((result << 4) & FLAG_BIT5));		// Move bits 1 and 3 of result-H into 5,3 respectively
	WZ++;
}


inline void Z80::Ini()
{
	// INI decrements B after it's placed on the bus
	// See http://www.cpcwiki.eu/forum/programming/z80-documentation-errors/
	WZ = BC + 1;
	applyMemoryContentionCompound(1, IR);					// M2 = 5
	BYTE val8 = ReadPort(BC);
	B--;
	WriteByte(HL++, val8);
	WORD rum = val8 + ((C + 1) & 0xff);
	SetF(tableZS35[B] | ((val8 >> 6) & FLAG_N) | (rum > 0xff ? FLAG_C | FLAG_H : 0) | tableParity[(rum & 7) ^ B]);
}


inline void Z80::Outi()
{
	applyMemoryContention(1, IR);					// M2 = 5
	BYTE val8 = ReadByte(HL++);
	B--;
	WritePort(BC, val8);
	WZ = BC + 1;	// WZ = BC_after_decrementing_B + 1
	WORD rum = val8 + L;
	SetF((tableZS35[B]) | ((val8 >> 6) & FLAG_N) | (rum > 0xff ? FLAG_C | FLAG_H : 0) | (tableParity[(rum & 7) ^ B]));
}


inline void Z80::Ldd()
{
	BYTE val8 = ReadByte(HL--);
	WriteByte(DE, val8);
	applyMemoryContentionCompound(2, DE);
	DE--;
	BC--;
	val8 += A;
	SetF((F & (FLAG_S | FLAG_Z | FLAG_C)) | (BC != 0 ? FLAG_P : 0) | ((val8 & FLAG_BIT3) | ((val8 << 4) & FLAG_BIT5)));
}


inline void Z80::Cpd()
{
	BYTE val8 = ReadByte(HL);
	applyMemoryContentionCompound(5, HL);
	HL--;
	BC--;
	BYTE result = A - val8;
	SetF(tableZS[result] |					// ZS
		(F & FLAG_C) |						// Leave C alone
		FLAG_N |							// N
		CalcFlagH(result, A, val8) |		// H
		(BC != 0 ? FLAG_P : 0));			// P
	result -= ((F & FLAG_H) >> 4);
	F |= ((result & FLAG_BIT3) | ((result << 4) & FLAG_BIT5));		// Move bits 1,3 of result-H into 3,5
	WZ--;
}


inline void Z80::Ind()
{
	// IND decrements B after it's placed on the bus
	// See http://www.cpcwiki.eu/forum/programming/z80-documentation-errors/
	WZ = BC - 1;
	applyMemoryContention(1, IR);			// M2 = 5
	BYTE val8 = ReadPort(BC);
	B--;
	WriteByte(HL--, val8);
	WORD rum = val8 + ((C - 1) & 0xff);
	SetF(tableZS35[B] | ((val8 >> 6) & FLAG_N) | (rum > 0xff ? FLAG_C | FLAG_H : 0) | tableParity[(rum & 7) ^ B]);
}


inline void Z80::Outd()
{
	applyMemoryContention(1, IR);			// M2 = 5
	BYTE val8 = ReadByte(HL--);
	B--;
	WritePort(BC, val8);
	WZ = BC - 1;	// WZ = BC_after_decrementing_B - 1
	WORD rum = val8 + L;
	SetF((tableZS35[B]) | ((val8 >> 6) & FLAG_N) | (rum > 0xff ? FLAG_C | FLAG_H : 0) | (tableParity[(rum & 7) ^ B]));
}


inline void Z80::Ldir()
{
	Ldi();
	if (BC)
	{
		applyMemoryContentionCompound(5, DE-1);		// DE-1 to allow for fact LDI has incremented it
		PC -= 2;
		WZ = PC + 1;
	}
}


inline void Z80::Cpir()
{
	Cpi();
	if (BC != 0 && (!(F & FLAG_Z)))
	{
		applyMemoryContentionCompound(5, HL-1);		// HL-1 to allow for fact CPI has incremented it
		PC -= 2;
		WZ = PC + 1;
	}
}


inline void Z80::Inir()
{
	Ini();
	if (B)
	{
		PC -= 2;
		applyMemoryContentionCompound(5, HL-1);		// HL-1 to allow for fact INI has incremented it
	}
}


inline void Z80::Otir()
{
	Outi();
	if (B)
	{
		applyMemoryContentionCompound(5, BC);
		PC -= 2;
	}
}


inline void Z80::Lddr()
{
	Ldd();
	if (BC)
	{
		applyMemoryContentionCompound(5, DE+1);		// DE+1 to allow for fact LDD has incremented it
		PC -= 2;
		WZ = PC + 1;
	}
}


inline void Z80::Cpdr()
{
	Cpd();
	if (BC != 0 && (!(F & FLAG_Z)))
	{
		applyMemoryContentionCompound(5, HL+1);		// HL+1 to allow for fact CPD has incremented it
		PC -= 2;
		WZ = PC + 1;
	}
}


inline void Z80::Indr()
{
	Ind();
	if (B)
	{
		PC -= 2;
		applyMemoryContentionCompound(5, HL+1);		// HL+1 to allow for fact IND has incremented it
	}
}


inline void Z80::Otdr()
{
	Outd();
	if (B)
	{
		applyMemoryContentionCompound(5, BC);
		PC -= 2;
	}
}


inline void Z80::Daa()
{
	BYTE correction = 0;
	BYTE carry = 0;			// state of the carry flag after the ADD/SUB
	if (A > 0x99 || (F & FLAG_C))
	{
		correction = (6 << 4);
		carry = FLAG_C;
	}
	else
	{
		F &= (~FLAG_C);
	}

	if ((A & 0x0f) > 9 || (F & FLAG_H))
		correction |= 6;

	if (F & FLAG_N)
		Sub(correction);
	else
		Add(correction);

	// Put the new carry back along with the new parity
	SetF((F & ~(FLAG_C | FLAG_P)) | carry | tableParity[A]);
}


inline void Z80::Push(WORD value)
{
	WriteByte(--SP, value >> 8);
	WriteByte(--SP, value & 0xff);
}


inline WORD Z80::Pop()
{
	WORD addr = ReadByte(SP++);
	addr += 256 * ReadByte(SP++);
	return addr;
}


template <BYTE (Z80::* FN)(BYTE)>
void Z80::RotShift(BYTE & r)
{
	if (_ddfdPrefix == PrefixNone)
	{
		// <rot/shift> r
		r = (this->*FN)(r);
	}
	else
	{
		// <rot/shift> (ixy+d),r
		WORD addr = HLIXIY + _opCBDisplacement;
		r = ReadByte(addr);
		applyMemoryContention(1, addr);		// M3 = 4
		r = (this->*FN)(r);
		WriteByte(addr, r);
	}
}


template <BYTE (Z80::* FN)(BYTE)>
void Z80::RotShiftHL()
{
	// NB _opCBDisplacement will have been set to 0  when _ddfdPrefix == PrefixNone,
	// so it works for the HL case fine.
	assert((_ddfdPrefix == PrefixNone && _opCBDisplacement == 0) || _ddfdPrefix != PrefixNone);
	WORD addr = HLIXIY + _opCBDisplacement;

	// <rot/shift> (ixy+d)
	BYTE b = ReadByte(addr);
	applyMemoryContention(1, addr);		// M3 = 4
	b = (this->*FN)(b);
	WriteByte(addr, b);
}


inline BYTE Z80::Rlc(BYTE val)
{
	BYTE newval = (val << 1) | (val >> 7);
	SetF(tableZS35P[newval] | (newval & FLAG_C));
	return newval;
}


inline BYTE Z80::Rrc(BYTE val)
{
	BYTE newval = (val >> 1) | (val << 7);
	SetF(tableZS35P[newval] | (val & FLAG_C));
	return newval;
}


inline BYTE Z80::Rl(BYTE val)
{
	BYTE newval = (val << 1) | (F & FLAG_C);
	SetF(tableZS35P[newval] | (val >> 7));
	return newval;
}


inline BYTE Z80::Rr(BYTE val)
{
	BYTE newval = (val >> 1) | (F << 7);
	SetF(tableZS35P[newval] | (val & FLAG_C));
	return newval;
}


inline BYTE Z80::Sla(BYTE val)
{
	BYTE newval = (val << 1);
	SetF(tableZS35P[newval] | ((val >> 7) & FLAG_C));
	return newval;
}


inline BYTE Z80::Sra(BYTE val)
{
	BYTE newval = (val >> 1) | (val & 0x80);
	SetF(tableZS35P[newval] | (val & FLAG_C));
	return newval;
}


inline BYTE Z80::Sll(BYTE val)
{
	BYTE newval = (val << 1) | 1;
	SetF(tableZS35P[newval] | (val >> 7));
	return newval;
}


inline BYTE Z80::Srl(BYTE val)
{
	BYTE newval = (val >> 1);
	SetF(tableZS35P[newval] | (val & FLAG_C));
	return newval;
}


inline void Z80::BitHL(BYTE bitmask)
{
	assert(bitmask != 0);
	if (_ddfdPrefix == PrefixNone)
	{
		assert(_opCBDisplacement == 0);
		BYTE val = ReadByte(HL);
		applyMemoryContention(1, HL);
		val &= bitmask;
		SetF(tableZS[val] |
			FLAG_H |
			(WZH & FLAGS_35) |
			(F & FLAG_C));
		F |= ((F & FLAG_Z) >> 4);	// PF = ZF
	}
	else
	{
		WORD addr = HLIXIY + _opCBDisplacement;
		BYTE val = ReadByte(addr);
		applyMemoryContention(1, addr);
		val &= bitmask;
		SetF(tableZS[val] |
			FLAG_H |
			((addr >> 8) & FLAGS_35) |
			(F & FLAG_C));
		F |= ((F & FLAG_Z) >> 4);	// PF = ZF
	}
}


inline void Z80::Bit(BYTE bitmask, BYTE val)
{
	if (_ddfdPrefix == PrefixNone)
	{
		assert(bitmask != 0);
		BYTE result = val & bitmask;
		SetF(tableZS[result] | FLAG_H | (F & FLAG_C) | (val & FLAGS_35));
		F |= ((F & FLAG_Z) >> 4);		// PF = ZF
	}
	else
	{
		// Undocument bit instruction, same as bit b,(HL)
		BitHL(bitmask);
	}
}


inline void Z80::Res(BYTE bitmask, BYTE & r)
{
	assert(bitmask);
	if (_ddfdPrefix == PrefixNone)
	{
		r &= bitmask;
	}
	else
	{
		WORD addr = HLIXIY + _opCBDisplacement;
		r = ReadByte(addr) & bitmask;
		applyMemoryContention(1, addr);
		WriteByte(addr, r);
	}
}


inline void Z80::ResHL(BYTE bitmask)
{
	assert(bitmask);
	assert((_ddfdPrefix == PrefixNone && _opCBDisplacement == 0) || _ddfdPrefix != PrefixNone);
	WORD addr = HLIXIY + _opCBDisplacement;
	BYTE b = ReadByte(addr);
	applyMemoryContention(1, addr);
	WriteByte(addr, b & bitmask);
}


inline void Z80::Set(BYTE bitmask, BYTE & r)
{
	assert(bitmask);
	assert((_ddfdPrefix == PrefixNone && _opCBDisplacement == 0) || _ddfdPrefix != PrefixNone);
	if (_ddfdPrefix == PrefixNone)
	{
		r |= bitmask;
	}
	else
	{
		WORD addr = HLIXIY + _opCBDisplacement;
		r = ReadByte(addr) | bitmask;
		applyMemoryContention(1, addr);
		WriteByte(addr, r);
	}
}


inline void Z80::SetHL(BYTE bitmask)
{
	assert(bitmask);
	assert((_ddfdPrefix == PrefixNone && _opCBDisplacement == 0) || _ddfdPrefix != PrefixNone);
	WORD addr = HLIXIY + _opCBDisplacement;
	BYTE b = ReadByte(addr);
	applyMemoryContention(1, addr);
	WriteByte(addr, b | bitmask);
}


void Z80::EDNop(BYTE opcode)
{
	acknowledgeEDNOP(PC, opcode);
}


void Z80::ExecuteInstruction()
{
	InstructionPrefix newPrefix = PrefixNone;
	_newModifiedFlags = false;
	setPostEI(false);
	BYTE op = ReadOpCode();

	BYTE	val8;
	WORD	reg16, addr;

	switch(op)
	{
	case 0x00:	// nop [4]
		break;

	case 0x01:	// ld bc,nn [10]
		BC = ReadWord();
		break;

	case 0x02:	// ld (bc),a [7]
		WriteByte(BC, A);
		WZL = C + 1;
		WZH = A;
		break;

	case 0x03:	// inc bc [6]
		applyMemoryContentionCompound(2, IR);		// M1 = 6
		BC++;
		break;

	case 0x04:	// inc b [4]
		Inc(B);
		break;

	case 0x05:	// dec b [4]
		Dec(B);
		break;

	case 0x06:	// ld b,n [7]
		B = ReadByte();
		break;

	case 0x07:	// rlca [4]
		A = (A << 1) | (A >> 7);
		SetF((F & (FLAG_S | FLAG_Z | FLAG_P)) | (A & (FLAGS_35 | FLAG_C)));
		break;

	case 0x08:	// ex af,af' [4]
		reg16 = AF;
		AF = AF_ALT;
		AF_ALT = reg16;
		// NB does not set flags modified flag
		break;

	case 0x09:	// add hl,bc [11]
		applyMemoryContentionCompound(4 + 3, IR);	// M2 = 4, M3 = 3
		AddHL(BC);
		break;

	case 0x0a:	// ld a,(bc) [7]
		A = ReadByte(BC);
		WZ = BC + 1;
		break;

	case 0x0b:	// dec bc [6]
		applyMemoryContentionCompound(2, IR);		// M1 = 6
		BC--;
		break;

	case 0x0c:	// inc c [4]
		Inc(C);
		break;

	case 0x0d:	// dec c [4]
		Dec(C);
		break;

	case 0x0e:	// ld c,n [7]
		C = ReadByte();
		break;

	case 0x0f:	// rrca [4]
		A = (A >> 1) | (A << 7);
		SetF((F & (FLAG_S | FLAG_Z | FLAG_P)) | (A & (FLAGS_35)) | (A >> 7));
		break;

	case 0x10:	// djnz [8/13]
		applyMemoryContention(1, IR);		// M1 = 5
		B--;
		if (B)
			Jr();
		else
			discardByte();
		break;

	case 0x11:	// ld de,nn [10]
		DE = ReadWord();
		break;

	case 0x12:	// ld (de),a [7]
		WriteByte(DE, A);
		WZL = E + 1;
		WZH = A;
		break;

	case 0x13:	// inc de [6]
		applyMemoryContentionCompound(2, IR);		// M1 = 6
		DE++;
		break;

	case 0x14:	// inc d [4]
		Inc(D);
		break;

	case 0x15:	// dec d [4]
		Dec(D);
		break;

	case 0x16:	// ld d,n [7]
		D = ReadByte();
		break;

	case 0x17:	// rla [4]
		val8 = A;
		A = (A << 1) | (F & FLAG_C);
		SetF((F & (FLAG_S | FLAG_Z | FLAG_P)) | (A & (FLAGS_35)) | (val8 >> 7));
		break;

	case 0x18:	// jr nn [12]
		Jr();
		break;

	case 0x19:	// add hl,de [11]
		applyMemoryContentionCompound(4 + 3, IR);		// M2 = 4, M3 = 3
		AddHL(DE);
		break;

	case 0x1a:	// ld a,(de) [7]
		A = ReadByte(DE);
		WZ = DE + 1;
		break;

	case 0x1b:	// dec de [6]
		applyMemoryContentionCompound(2, IR);			// M1 = 6
		DE--;
		break;

	case 0x1c:	// inc e [4]
		Inc(E);
		break;

	case 0x1d:	// dec e [4]
		Dec(E);
		break;

	case 0x1e:	// ld e,n [7]
		E = ReadByte();
		break;

	case 0x1f:	// rra [4]
		val8 = A;
		A = (A >> 1) | (F << 7);
		SetF((F & (FLAG_S | FLAG_Z | FLAG_P)) | (A & (FLAGS_35)) | (val8 & FLAG_C));
		break;

	case 0x20:	// jr nz [7/12]
		Jr(!(F & FLAG_Z));
		break;

	case 0x21:	// ld hl,nn [10]
		HLIXIY = ReadWord();
		break;

	case 0x22:	// ld (nn),hl [16]
		addr = ReadWord();
		WZ = addr + 1;
		WriteWord(addr, HLIXIY);
		break;

	case 0x23:	// inc hl [6]
		applyMemoryContentionCompound(2, IR);		// M1 = 6
		HLIXIY++;
		break;

	case 0x24:	// inc h [4]
		Inc(HIXHIYH);
		break;

	case 0x25:	// dec h [4]
		Dec(HIXHIYH);
		break;

	case 0x26:	// ld h,n [7]
		HIXHIYH = ReadByte();
		break;

	case 0x27:	// daa [4]
		Daa();
		break;

	case 0x28:	// jr z [7/12]
		Jr((F & FLAG_Z) != 0);
		break;

	case 0x29:	// add hl,hl [11]
		applyMemoryContentionCompound(4 + 3, IR);		// M2 = 4, M3 = 3
		AddHL(HLIXIY);
		break;

	case 0x2a:	// ld hl,(nn) [16]
		addr = ReadWord();
		WZ = addr + 1;
		HLIXIY = ReadWord(addr);
		break;

	case 0x2b:	// dec hl [6]
		applyMemoryContentionCompound(2, IR);		// M1 = 6
		HLIXIY--;
		break;

	case 0x2c:	// inc l [4]
		Inc(LIXLIYL);
		break;

	case 0x2d:	// dec l [4]
		Dec(LIXLIYL);
		break;

	case 0x2e:	// ld l,n [7]
		LIXLIYL = ReadByte();
		break;

	case 0x2f:	// cpl [4]
		A = ~A;
		SetF((F & (~FLAGS_35)) | (A & FLAGS_35) | FLAG_H | FLAG_N);
		break;

	case 0x30:	// jr nc [7/12]
		Jr(!(F & FLAG_C));
		break;

	case 0x31:	// ld sp,nn [10]
		SP = ReadWord();
		break;

	case 0x32:	// ld (nn),a [13]
		addr = ReadWord();
		WZL = addr + 1;
		WZH = A;
		WriteByte(addr, A);
		break;

	case 0x33:	// inc sp [6]
		applyMemoryContentionCompound(2, IR);		// M1 = 6
		SP++;
		break;

	case 0x34:	// inc (hl) [11]
		addr = GetEA();
		val8 = ReadByte(addr);
		applyMemoryContention(1, addr);
		Inc(val8);
		WriteByte(addr, val8);
		break;

	case 0x35:	// dec (hl) [11]
		addr = GetEA();
		val8 = ReadByte(addr);
		applyMemoryContention(1, addr);		// M2 = 4
		Dec(val8);
		WriteByte(addr, val8);
		break;

	case 0x36:	// ld (hl),n [10]
		GetEAImm(addr, val8);
		WriteByte(addr, val8);
		break;

	case 0x37:	// scf [4]
		// The content of A is copied to flags 5+3 after SCF/CCF if the previous operation did set the flags,
		// whereas it is ORed in there if it didn't set the flags."
		val8 = _lastInstructionModifiedFlags ? 0 : F;
		SetF((F & (~(FLAGS_35 | FLAG_N | FLAG_H))) | ((A | val8) & FLAGS_35) | FLAG_C);
		break;

	case 0x38:	// jr c [7/12]
		Jr((F & FLAG_C) != 0);
		break;

	case 0x39:	// add hl,sp [11]
		applyMemoryContentionCompound(4 + 3, IR);		// M2 = 4, M3 = 3
		AddHL(SP);
		break;

	case 0x3a:	// ld a,(nn) [13]
		addr = ReadWord();
		WZ = addr + 1;
		A = ReadByte(addr);
		break;

	case 0x3b:	// dec sp [6]
		applyMemoryContentionCompound(2, IR);		// M1 = 6
		SP--;
		break;

	case 0x3c:	// inc a [4]
		Inc(A);
		break;

	case 0x3d:	// dec a [4]
		Dec(A);
		break;

	case 0x3e:	// ld a,n [7]
		A = ReadByte();
		break;

	case 0x3f:	// ccf [4]
		// The content of A is copied to flags 5+3 after SCF/CCF if the previous operation did set the flags,
		// whereas it is ORed in there if it didn't set the flags."
		val8 = _lastInstructionModifiedFlags ? 0 : F;
		SetF(((F & (FLAG_S | FLAG_Z | FLAG_P | FLAG_C)) | ((A | val8) & FLAGS_35) | ((F & FLAG_C) << 4)) ^ FLAG_C);
		break;

	case 0x40:	// ld b,b [4]
		break;

	case 0x41:	// ld b,c [4]
		B = C;
		break;

	case 0x42:	// ld b,d [4]
		B = D;
		break;

	case 0x43:	// ld b,e [4]
		B = E;
		break;

	case 0x44:	// ld b,h [4]
		B = HIXHIYH;
		break;

	case 0x45:	// ld b,l [4]
		B = LIXLIYL;
		break;

	case 0x46:	// ld b,(hl); [7]
		addr = GetEA();
		B = ReadByte(addr);
		break;

	case 0x47:	// ld b,a [4]
		B = A;
		break;

	case 0x48:	// ld c,b [4]
		C = B;
		break;

	case 0x49:	// ld c,c [4]
		break;

	case 0x4a:	// ld c,d [4]
		C = D;
		break;

	case 0x4b:	// ld c,e [4]
		C = E;
		break;

	case 0x4c:	// ld c,h [4]
		C = HIXHIYH;
		break;

	case 0x4d:	// ld c,l [4]
		C = LIXLIYL;
		break;

	case 0x4e:	// ld c,(hl) [7]
		addr = GetEA();
		C = ReadByte(addr);
		break;

	case 0x4f:	// ld c,a [4]
		C = A;
		break;

	case 0x50:	// ld d,b [4]
		D = B;
		break;

	case 0x51:	// ld d,c [4]
		D = C;
		break;

	case 0x52:	// ld d,d [4]
		break;

	case 0x53:	// ld d,e [4]
		D = E;
		break;

	case 0x54:	// ld d,h [4]
		D = HIXHIYH;
		break;

	case 0x55:	// ld d,l [4]
		D = LIXLIYL;
		break;

	case 0x56:	// ld d,(hl) [7]
		addr = GetEA();
		D = ReadByte(addr);
		break;

	case 0x57:	// ld d,a [4]
		D = A;
		break;

	case 0x58:	// ld e,b [4]
		E = B;
		break;

	case 0x59:	// ld e,c [4]
		E = C;
		break;

	case 0x5a:	// ld e,d [4]
		E = D;
		break;

	case 0x5b:	// ld e,e [4]
		break;

	case 0x5c:	// ld e,h [4]
		E = HIXHIYH;
		break;

	case 0x5d:	// ld e,l [4]
		 E = LIXLIYL;
		break;

	case 0x5e:	// ld e,(hl) [7]
		addr = GetEA();
		E = ReadByte(addr);
		break;

	case 0x5f:	// ld e,a [4]
		E = A;
		break;

	case 0x60:	// ld h,b [4]
		HIXHIYH = B;
		break;

	case 0x61:	// ld h,c [4]
		HIXHIYH = C;
		break;

	case 0x62:	// ld h,d [4]
		HIXHIYH = D;
		break;

	case 0x63:	// ld h,e [4]
		HIXHIYH = E;
		break;

	case 0x64:	// ld h,h [4]
		break;

	case 0x65:	// ld h,l [4]
		HIXHIYH = LIXLIYL;
		break;

	case 0x66:	// ld h,(hl) [7]
		addr = GetEA();
		H = ReadByte(addr);
		break;

	case 0x67:	// ld h,a [4]
		HIXHIYH = A;
		break;

	case 0x68:	// ld l,b [4]
		LIXLIYL = B;
		break;

	case 0x69:	// ld l,c [4]
		LIXLIYL = C;
		break;

	case 0x6a:	// ld l,d [4]
		LIXLIYL = D;
		break;

	case 0x6b:	// ld l,e [4]
		LIXLIYL = E;
		break;

	case 0x6c:	// ld l,h [4]
		LIXLIYL = HIXHIYH;
		break;

	case 0x6d:	// ld l,l [4]
		break;

	case 0x6e:	// ld l,(hl) [7]
		addr = GetEA();
		L = ReadByte(addr);
		break;

	case 0x6f:	// ld l,a [4]
		LIXLIYL = A;
		break;

	case 0x70:	// ld (hl),b [7]
		addr = GetEA();
		WriteByte(addr, B);
		break;

	case 0x71:	// ld (hl),c [7]
		addr = GetEA();
		WriteByte(addr, C);
		break;

	case 0x72:	// ld (hl),d [7]
		addr = GetEA();
		WriteByte(addr, D);
		break;

	case 0x73:	// ld (hl),e [7]
		addr = GetEA();
		WriteByte(addr, E);
		break;

	case 0x74:	// ld (hl),h [7]
		addr = GetEA();
		WriteByte(addr, H);
		break;

	case 0x75:	// ld (hl),l [7]
		addr = GetEA();
		WriteByte(addr, L);
		break;

	case 0x76:	// halt [4]
		setHalted(true);
		// Zilog docs claim it does a read but ignores it and executes a nop. So not handled correctly here.
		PC--;
		break;

	case 0x77:	// ld (hl),a [7]
		addr = GetEA();
		WriteByte(addr, A);
		break;

	case 0x78:	// ld a,b [4]
		A = B;
		break;

	case 0x79:	// ld a,c [4]
		A = C;
		break;

	case 0x7a:	// a,d [4]
		A = D;
		break;

	case 0x7b:	// a,e [4]
		A = E;
		break;

	case 0x7c:	// a,h [4]
		A = HIXHIYH;
		break;

	case 0x7d:	// a,l [4]
		A = LIXLIYL;
		break;

	case 0x7e:	// ld a,(hl) [7]
		addr = GetEA();
		A = ReadByte(addr);
		break;

	case 0x7f:	// ld a,a [4]
		break;

	case 0x80:	// add a,b [4]
		Add(B);
		break;

	case 0x81:	// add a,c [4]
		Add(C);
		break;

	case 0x82:	// add a,d [4]
		Add(D);
		break;

	case 0x83:	// add a,e [4]
		Add(E);
		break;

	case 0x84:	// add a,h [4]
		Add(HIXHIYH);
		break;

	case 0x85:	// add a,l [4]
		Add(LIXLIYL);
		break;

	case 0x86:	// add a,(hl) [7]
		addr = GetEA();
		Add(ReadByte(addr));
		break;

	case 0x87:	// add a,a [4]
		Add(A);
		break;

	case 0x88:	// adc a,b [4]
		Adc(B);
		break;

	case 0x89:	// adc a,c [4]
		Adc(C);
		break;

	case 0x8a:	// adc a,d [4]
		Adc(D);
		break;

	case 0x8b:	// adc a,e [4]
		Adc(E);
		break;

	case 0x8c:	// adc a,h [4]
		Adc(HIXHIYH);
		break;

	case 0x8d:	// adc a,l [4]
		Adc(LIXLIYL);
		break;

	case 0x8e:	// adc a,(hl) [7]
		addr = GetEA();
		Adc(ReadByte(addr));
		break;

	case 0x8f:	// adc a,a [4]
		Adc(A);
		break;

	case 0x90:	// sub b [4]
		Sub(B);
		break;

	case 0x91:	// sub c [4]
		Sub(C);
		break;

	case 0x92:	// sub d [4]
		Sub(D);
		break;

	case 0x93:	// sub e [4]
		Sub(E);
		break;

	case 0x94:	// sub h [4]
		Sub(HIXHIYH);
		break;

	case 0x95:	// sub l [4]
		Sub(LIXLIYL);
		break;

	case 0x96:	// sub (hl) [7]
		addr = GetEA();
		Sub(ReadByte(addr));
		break;

	case 0x97:	// sub a [4]
		Sub(A);
		break;

	case 0x98:	// sbc a,b [4]
		Sbc(B);
		break;

	case 0x99:	// sbc a,c [4]
		Sbc(C);
		break;

	case 0x9a:	// sbc a,d [4]
		Sbc(D);
		break;

	case 0x9b:	// sbc a,e [4]
		Sbc(E);
		break;

	case 0x9c:	// sbc a,h [4]
		Sbc(HIXHIYH);
		break;

	case 0x9d:	// sbc a,l [4]
		Sbc(LIXLIYL);
		break;

	case 0x9e:	// sbc a,(hl) [7]
		addr = GetEA();
		Sbc(ReadByte(addr));
		break;

	case 0x9f:	// sbc a,a [4]
		Sbc(A);
		break;

	case 0xa0:	// and b [4]
		And(B);
		break;

	case 0xa1:	// and c [4]
		And(C);
		break;

	case 0xa2:	// and d [4]
		And(D);
		break;

	case 0xa3:	// and e [4]
		And(E);
		break;

	case 0xa4:	// and h [4]
		And(HIXHIYH);
		break;

	case 0xa5:	// and l [4]
		And(LIXLIYL);
		break;

	case 0xa6:	// and (hl); [7]
		addr = GetEA();
		And(ReadByte(addr));
		break;

	case 0xa7:	// and a [4]
		And(A);
		break;

	case 0xa8:	// xor b [4]
		Xor(B);
		break;

	case 0xa9:	// xor c [4]
		Xor(C);
		break;

	case 0xaa:	// xor d [4]
		Xor(D);
		break;

	case 0xab:	// xor e [4]
		Xor(E);
		break;

	case 0xac:	// xor h [4]
		Xor(HIXHIYH);
		break;

	case 0xad:	// xor l [4]
		Xor(LIXLIYL);
		break;

	case 0xae:	// xor (hl) [7]
		addr = GetEA();
		Xor(ReadByte(addr));
		break;

	case 0xaf:	// xor a [4]
		Xor(A);
		break;

	case 0xb0:	// or b [4]
		Or(B);
		break;

	case 0xb1:	// or c [4]
		Or(C);
		break;

	case 0xb2:	// or d [4]
		Or(D);
		break;

	case 0xb3:	// or e [4]
		Or(E);
		break;

	case 0xb4:	// or h [4]
		Or(HIXHIYH);
		break;

	case 0xb5:	// or l [4]
		Or(LIXLIYL);
		break;

	case 0xb6:	// or (hl) [7]
		addr = GetEA();
		Or(ReadByte(addr));
		break;

	case 0xb7:	// or a [4]
		Or(A);
		break;

	case 0xb8:	// cp b [4]
		Cp(B);
		break;

	case 0xb9:	// cp c [4]
		Cp(C);
		break;

	case 0xba:	// cp d [4]
		Cp(D);
		break;

	case 0xbb:	// cp e [4]
		Cp(E);
		break;

	case 0xbc:	// cp h [4]
		Cp(HIXHIYH);
		break;

	case 0xbd:	// cp l [4]
		Cp(LIXLIYL);
		break;

	case 0xbe:	// cp (hl) [7]
		addr = GetEA();
		Cp(ReadByte(addr));
		break;

	case 0xbf:	// cp a [4]
		Cp(A);
		break;

	case 0xc0:	// ret nz [5/11]
		Ret(!(F & FLAG_Z));
		break;

	case 0xc1:	// pop bc [10]
		BC = Pop();
		break;

	case 0xc2:	// jp nz [10/10]
		Jp(!(F & FLAG_Z));
		break;

	case 0xc3:	// jp [10]
		Jp();
		break;

	case 0xc4:	// call nz [10/17]
		Call(!(F & FLAG_Z));
		break;

	case 0xc5:	// push bc [11]
		applyMemoryContention(1, IR);		// M1 = 5
		Push(BC);
		break;

	case 0xc6:	// add a,n [7]
		Add(ReadByte());
		break;

	case 0xc7:	// rst 0 [11]
		Rst(0x00);
		break;

	case 0xc8:	// ret z
		Ret((F & FLAG_Z) != 0);
		break;

	case 0xc9:	// ret [10]
		Ret();
		break;

	case 0xca:	// jp z [10/10]
		Jp((F & FLAG_Z) != 0);
		break;

	case 0xcb:	// rotates, bits, sets and resets
		OpCB();
		break;

	case 0xcc:	// call z [10/17]
		Call((F & FLAG_Z) != 0);
		break;

	case 0xcd:	// call [17]
		Call();
		break;

	case 0xce:	// adc a,n [7]
		Adc(ReadByte());
		break;

	case 0xcf:	// rst 8h [11]
		Rst(0x08);
		break;

	case 0xd0:	// ret nc [5/11]
		Ret(!(F & FLAG_C));
		break;

	case 0xd1:	// pop de [10]
		DE = Pop();
		break;

	case 0xd2:	// jp nc [10/10]
		Jp(!(F & FLAG_C));
		break;

	case 0xd3:	// out (n),a [11]
		addr = ReadByte() + 256 * A;
		WZL = (BYTE)(addr + 1);
		WZH = A;
		WritePort(addr, A);		// M3 = 4
		break;

	case 0xd4:	// call nc [10/17]
		Call(!(F & FLAG_C));
		break;

	case 0xd5:	// push de [11]
		applyMemoryContention(1, IR);		// M1 = 5
		Push(DE);
		break;

	case 0xd6:	// sub n [7]
		Sub(ReadByte());
		break;

	case 0xd7:	// rst 0x10 [11]
		Rst(0x10);
		break;

	case 0xd8:	// ret c [5/11]
		Ret((F & FLAG_C) != 0);
		break;

	case 0xd9:	// exx [4]
		reg16 = BC;	BC = BC_ALT; BC_ALT = reg16;
		reg16 = DE; DE = DE_ALT; DE_ALT = reg16;
		reg16 = HL; HL = HL_ALT; HL_ALT = reg16;
		break;

	case 0xda:	// jp c [10/10]
		Jp((F & FLAG_C) != 0);
		break;

	case 0xdb:	// in a,(n) [11]
		addr = ReadByte() + 256 * A;
		WZ = addr + 1;
		A = ReadPort(addr);	// M3 = 4
		break;

	case 0xdc:	// call c [10/17]
		Call((F & FLAG_C) != 0);
		break;

	case 0xdd:	// ix prefix [4]
		newPrefix = PrefixIX;
		break;

	case 0xde:	// sbc a,n [4]
		Sbc(ReadByte());
		break;

	case 0xdf:	// rst 0x18 [11]
		Rst(0x18);
		break;

	case 0xe0:	// ret po [5/11]
		Ret(!(F & FLAG_P));
		break;

	case 0xe1:	// pop hl [10]
		HLIXIY = Pop();
		break;

	case 0xe2:	// jp po [10/10]
		Jp(!(F & FLAG_P));
		break;

	case 0xe3:	// ex (sp),hl [19]
		reg16 = ReadWord(SP);
		applyMemoryContention(1, SP + 1);
		WriteByte(SP+1, HLIXIY >> 8);
		WriteByte(SP, HLIXIY & 0xff);
		applyMemoryContentionCompound(2, SP);	// M5 = 5
		HLIXIY = reg16;
		WZ = reg16;
		break;

	case 0xe4:	// call po [10/17]
		Call(!(F & FLAG_P));
		break;

	case 0xe5:	// push hl [11]
		applyMemoryContention(1, IR);		// M1 = 5
		Push(HLIXIY);
		break;

	case 0xe6:	// and n [7]
		And(ReadByte());
		break;

	case 0xe7:	// rst 0x20 [11]
		Rst(0x20);
		break;

	case 0xe8:	// ret pe [5/11]
		Ret((F & FLAG_P) != 0);
		break;

	case 0xe9:	// jp (hl) [4]
		PC = HLIXIY;
		break;

	case 0xea:	// jp pe [10/10]
		Jp((F & FLAG_P) != 0);
		break;

	case 0xeb:	// ex de,hl [4]
		reg16 = HL;
		HL = DE;
		DE = reg16;
		break;

	case 0xec:	// call pe [10/17]
		Call((F & FLAG_P) != 0);
		break;

	case 0xed:	// ed prefix
		_ddfdPrefix = newPrefix = PrefixNone;		// "If a DD or FD precedes an ED instruction, the DD or FD is ignored."
		OpED();
		break;

	case 0xee:	// xor n [7]
		Xor(ReadByte());
		break;

	case 0xef:	// rst 28h [11]
		Rst(0x28);
		break;

	case 0xf0:	// ret p [5/11]
		Ret(!(F & FLAG_S));
		break;

	case 0xf1:	// pop af [10]
		AF = Pop();
		// NB we do not set flags modified flag
		break;

	case 0xf2:	// jp p [10/10]
		Jp(!(F & FLAG_S));
		break;

	case 0xf3:	// di [4]
		IFF1 = IFF2 = FlipFlopReset;
		break;

	case 0xf4:	// call p [10/17]
		Call(!(F & FLAG_S));
		break;

	case 0xf5:	// push af [11]
		applyMemoryContention(1, IR);		// M1 = 5
		Push(AF);
		break;

	case 0xf6:	// or n [7]
		Or(ReadByte());
		break;

	case 0xf7:	// rst 30h [11]
		Rst(0x30);
		break;

	case 0xf8:	// ret m [5/11]
		Ret((F & FLAG_S) != 0);
		break;

	case 0xf9:	// ld sp,hl [6]
		applyMemoryContentionCompound(2, IR);
		SP = HLIXIY;
		break;

	case 0xfa:	// jp m [10/10]
		Jp((F & FLAG_S) != 0);
		break;

	case 0xfb:	// ei [4]
		IFF1 = IFF2 = FlipFlopSet;
		setPostEI(true);
		break;

	case 0xfc:	// call m [10/17]
		Call((F & FLAG_S) != 0);
		break;

	case 0xfd:	// iy prefix [4]
		newPrefix = PrefixIY;
		break;

	case 0xfe:	// cp n [7]
		Cp(ReadByte());
		break;

	case 0xff:	// rst 038h [11]
		Rst(0x38);
		break;
	}

	_ddfdPrefix = newPrefix;
	_lastInstructionModifiedFlags = _newModifiedFlags;
}


void Z80::OpCB()
{
	BYTE op3;
	if (_ddfdPrefix == PrefixNone)
	{
		_MREQLine = _RDLine = LineLow;
		_opCBDisplacement = 0;
		applyMemoryContention(4, PC);
		op3 = memoryReadRaw(PC++);
		_MREQLine = _RDLine = LineHigh;
		IncR();
	}
	else
	{
		// For DDCBddxx opcodes, the ix/iy displacement is specified as the 3rd byte, so grab it now.
		_opCBDisplacement = ReadByte();
		op3 = ReadByte();
		applyMemoryContentionCompound(2, PC-1);
		// DDCBnn opcodes only increment R twice, not three times, so IncR() isn't called here.
	}

	switch(op3)
	{
	// RLC r / RLC (ixy+d),r
	case 0x00:	RotShift<&Z80::Rlc>(B);		break;		// rlc b
	case 0x01:	RotShift<&Z80::Rlc>(C);		break;		// rlc c
	case 0x02:	RotShift<&Z80::Rlc>(D);		break;		// rlc d
	case 0x03:	RotShift<&Z80::Rlc>(E);		break;		// rlc e
	case 0x04:	RotShift<&Z80::Rlc>(H);		break;		// rlc h
	case 0x05:	RotShift<&Z80::Rlc>(L);		break;		// rlc l
	case 0x06:	RotShiftHL<&Z80::Rlc>();	break;		// rlc (hl)
	case 0x07:	RotShift<&Z80::Rlc>(A);		break;		// rlc a

	// RRC r / RRC (ixy+d),r
	case 0x08:	RotShift<&Z80::Rrc>(B);		break;		// rrc b
	case 0x09:	RotShift<&Z80::Rrc>(C);		break;		// rrc c
	case 0x0a:	RotShift<&Z80::Rrc>(D);		break;		// rrc d
	case 0x0b:	RotShift<&Z80::Rrc>(E);		break;		// rrc e
	case 0x0c:	RotShift<&Z80::Rrc>(H);		break;		// rrc h
	case 0x0d:	RotShift<&Z80::Rrc>(L);		break;		// rrc l
	case 0x0e:	RotShiftHL<&Z80::Rrc>();	break;		// rrc (hl)
	case 0x0f:	RotShift<&Z80::Rrc>(A);		break;		// rrc a

	// RL r / RL (ixy+d),r
	case 0x10:	RotShift<&Z80::Rl>(B);		break;		// rl b
	case 0x11:	RotShift<&Z80::Rl>(C);		break;		// rl c
	case 0x12:	RotShift<&Z80::Rl>(D);		break;		// rl d
	case 0x13:	RotShift<&Z80::Rl>(E);		break;		// rl e
	case 0x14:	RotShift<&Z80::Rl>(H);		break;		// rl h
	case 0x15:	RotShift<&Z80::Rl>(L);		break;		// rl l
	case 0x16:	RotShiftHL<&Z80::Rl>();		break;		// rl (hl)
	case 0x17:	RotShift<&Z80::Rl>(A);		break;		// rl a

	// RR r / RR (ixy+d),r
	case 0x18:	RotShift<&Z80::Rr>(B);		break;		// rr b
	case 0x19:	RotShift<&Z80::Rr>(C);		break;		// rr c
	case 0x1a:	RotShift<&Z80::Rr>(D);		break;		// rr d
	case 0x1b:	RotShift<&Z80::Rr>(E);		break;		// rr e
	case 0x1c:	RotShift<&Z80::Rr>(H);		break;		// rr h
	case 0x1d:	RotShift<&Z80::Rr>(L);		break;		// rr l
	case 0x1e:	RotShiftHL<&Z80::Rr>();		break;		// rr (hl)
	case 0x1f:	RotShift<&Z80::Rr>(A);		break;		// rr a

	// SLA r / SLA (ixy+d),r
	case 0x20:	RotShift<&Z80::Sla>(B);		break;		// sla b
	case 0x21:	RotShift<&Z80::Sla>(C);		break;		// sla c
	case 0x22:	RotShift<&Z80::Sla>(D);		break;		// sla d
	case 0x23:	RotShift<&Z80::Sla>(E);		break;		// sla e
	case 0x24:	RotShift<&Z80::Sla>(H);		break;		// sla h
	case 0x25:	RotShift<&Z80::Sla>(L);		break;		// sla l
	case 0x26:	RotShiftHL<&Z80::Sla>();	break;		// sla (hl)
	case 0x27:	RotShift<&Z80::Sla>(A);		break;		// sla a

	// SRA r / SRA (ixy+d),r
	case 0x28:	RotShift<&Z80::Sra>(B);		break;		// sra b
	case 0x29:	RotShift<&Z80::Sra>(C);		break;		// sra c
	case 0x2a:	RotShift<&Z80::Sra>(D);		break;		// sra d
	case 0x2b:	RotShift<&Z80::Sra>(E);		break;		// sra e
	case 0x2c:	RotShift<&Z80::Sra>(H);		break;		// sra h
	case 0x2d:	RotShift<&Z80::Sra>(L);		break;		// sra l
	case 0x2e:	RotShiftHL<&Z80::Sra>();	break;		// sra (hl)
	case 0x2f:	RotShift<&Z80::Sra>(A);		break;		// sra a

	// SLL r / SLL (ixy+d),r
	case 0x30:	RotShift<&Z80::Sll>(B);		break;		// sll b
	case 0x31:	RotShift<&Z80::Sll>(C);		break;		// sll c
	case 0x32:	RotShift<&Z80::Sll>(D);		break;		// sll d
	case 0x33:	RotShift<&Z80::Sll>(E);		break;		// sll e
	case 0x34:	RotShift<&Z80::Sll>(H);		break;		// sll h
	case 0x35:	RotShift<&Z80::Sll>(L);		break;		// sll l
	case 0x36:	RotShiftHL<&Z80::Sll>();	break;		// sll (hl)
	case 0x37:	RotShift<&Z80::Sll>(A);		break;		// sll a

	// SRL r / SRL (ixy+d),r
	case 0x38:	RotShift<&Z80::Srl>(B);		break;		// srl b
	case 0x39:	RotShift<&Z80::Srl>(C);		break;		// srl c
	case 0x3a:	RotShift<&Z80::Srl>(D);		break;		// srl d
	case 0x3b:	RotShift<&Z80::Srl>(E);		break;		// srl e
	case 0x3c:	RotShift<&Z80::Srl>(H);		break;		// srl h
	case 0x3d:	RotShift<&Z80::Srl>(L);		break;		// srl l
	case 0x3e:	RotShiftHL<&Z80::Srl>();	break;		// srl (hl)
	case 0x3f:	RotShift<&Z80::Srl>(A);		break;		// srl a

	// BIT b, r / BIT b,(ixy+d)
	case 0x40:	Bit(Bit0, B);	break;	// bit 0,b
	case 0x41:	Bit(Bit0, C);	break;	// bit 0,c
	case 0x42:	Bit(Bit0, D);	break;	// bit 0,d
	case 0x43:	Bit(Bit0, E);	break;	// bit 0,e
	case 0x44:	Bit(Bit0, H);	break;	// bit 0,h
	case 0x45:	Bit(Bit0, L);	break;	// bit 0,l
	case 0x46:	BitHL(Bit0);	break;	// bit 0,(hl)
	case 0x47:	Bit(Bit0, A);	break;	// bit 0,a

	case 0x48:	Bit(Bit1, B);	break;	// bit 1,b
	case 0x49:	Bit(Bit1, C);	break;	// bit 1,c
	case 0x4a:	Bit(Bit1, D);	break;	// bit 1,d
	case 0x4b:	Bit(Bit1, E);	break;	// bit 1,e
	case 0x4c:	Bit(Bit1, H);	break;	// bit 1,h
	case 0x4d:	Bit(Bit1, L);	break;	// bit 1,l
	case 0x4e:	BitHL(Bit1);	break;	// bit 1,(hl)
	case 0x4f:	Bit(Bit1, A);	break;	// bit 1,a

	case 0x50:	Bit(Bit2, B);	break;	// bit 2,b
	case 0x51:	Bit(Bit2, C);	break;	// bit 2,c
	case 0x52:	Bit(Bit2, D);	break;	// bit 2,d
	case 0x53:	Bit(Bit2, E);	break;	// bit 2,e
	case 0x54:	Bit(Bit2, H);	break;	// bit 2,h
	case 0x55:	Bit(Bit2, L);	break;	// bit 2,l
	case 0x56:	BitHL(Bit2);	break;	// bit 2,(hl)
	case 0x57:	Bit(Bit2, A);	break;	// bit 2,a

	case 0x58:	Bit(Bit3, B);	break;	// bit 3,b
	case 0x59:	Bit(Bit3, C);	break;	// bit 3,c
	case 0x5a:	Bit(Bit3, D);	break;	// bit 3,d
	case 0x5b:	Bit(Bit3, E);	break;	// bit 3,e
	case 0x5c:	Bit(Bit3, H);	break;	// bit 3,h
	case 0x5d:	Bit(Bit3, L);	break;	// bit 3,l
	case 0x5e:	BitHL(Bit3);	break;	// bit 3,(hl)
	case 0x5f:	Bit(Bit3, A);	break;	// bit 3,a

	case 0x60:	Bit(Bit4, B);	break;	// bit 4,b
	case 0x61:	Bit(Bit4, C);	break;	// bit 4,c
	case 0x62:	Bit(Bit4, D);	break;	// bit 4,d
	case 0x63:	Bit(Bit4, E);	break;	// bit 4,e
	case 0x64:	Bit(Bit4, H);	break;	// bit 4,h
	case 0x65:	Bit(Bit4, L);	break;	// bit 4,l
	case 0x66:	BitHL(Bit4);	break;	// bit 4,(hl)
	case 0x67:	Bit(Bit4, A);	break;	// bit 4,a

	case 0x68:	Bit(Bit5, B);	break;	// bit 5,b
	case 0x69:	Bit(Bit5, C);	break;	// bit 5,c
	case 0x6a:	Bit(Bit5, D);	break;	// bit 5,d
	case 0x6b:	Bit(Bit5, E);	break;	// bit 5,e
	case 0x6c:	Bit(Bit5, H);	break;	// bit 5,h
	case 0x6d:	Bit(Bit5, L);	break;	// bit 5,l
	case 0x6e:	BitHL(Bit5);	break;	// bit 5,(hl)
	case 0x6f:	Bit(Bit5, A);	break;	// bit 5,a

	case 0x70:	Bit(Bit6, B);	break;	// bit 6,b
	case 0x71:	Bit(Bit6, C);	break;	// bit 6,c
	case 0x72:	Bit(Bit6, D);	break;	// bit 6,d
	case 0x73:	Bit(Bit6, E);	break;	// bit 6,e
	case 0x74:	Bit(Bit6, H);	break;	// bit 6,h
	case 0x75:	Bit(Bit6, L);	break;	// bit 6,l
	case 0x76:	BitHL(Bit6);	break;	// bit 6,(hl)
	case 0x77:	Bit(Bit6, A);	break;	// bit 6,a

	case 0x78:	Bit(Bit7, B);	break;	// bit 7,b
	case 0x79:	Bit(Bit7, C);	break;	// bit 7,c
	case 0x7a:	Bit(Bit7, D);	break;	// bit 7,d
	case 0x7b:	Bit(Bit7, E);	break;	// bit 7,e
	case 0x7c:	Bit(Bit7, H);	break;	// bit 7,h
	case 0x7d:	Bit(Bit7, L);	break;	// bit 7,l
	case 0x7e:	BitHL(Bit7);	break;	// bit 7,(hl)
	case 0x7f:	Bit(Bit7, A);	break;	// bit 7,a

	// RES b, r / RES b,(ixy+d), r
	case 0x80:	Res(~Bit0, B);	break;	// res 0,b
	case 0x81:	Res(~Bit0, C);	break;	// res 0,c
	case 0x82:	Res(~Bit0, D);	break;	// res 0,d
	case 0x83:	Res(~Bit0, E);	break;	// res 0,e
	case 0x84:	Res(~Bit0, H);	break;	// res 0,h
	case 0x85:	Res(~Bit0, L);	break;	// res 0,l
	case 0x86:	ResHL(~Bit0);	break;	// res 0,(hl)
	case 0x87:	Res(~Bit0, A);	break;	// res 0,a

	case 0x88:	Res(~Bit1, B);	break;	// res 1,b
	case 0x89:	Res(~Bit1, C);	break;	// res 1,c
	case 0x8a:	Res(~Bit1, D);	break;	// res 1,d
	case 0x8b:	Res(~Bit1, E);	break;	// res 1,e
	case 0x8c:	Res(~Bit1, H);	break;	// res 1,h
	case 0x8d:	Res(~Bit1, L);	break;	// res 1,l
	case 0x8e:	ResHL(~Bit1);	break;	// res 1,(hl)
	case 0x8f:	Res(~Bit1, A);	break;	// res 1,a

	case 0x90:	Res(~Bit2, B);	break;	// res 2,b
	case 0x91:	Res(~Bit2, C);	break;	// res 2,c
	case 0x92:	Res(~Bit2, D);	break;	// res 2,d
	case 0x93:	Res(~Bit2, E);	break;	// res 2,e
	case 0x94:	Res(~Bit2, H);	break;	// res 2,h
	case 0x95:	Res(~Bit2, L);	break;	// res 2,l
	case 0x96:	ResHL(~Bit2);	break;	// res 2,(hl)
	case 0x97:	Res(~Bit2, A);	break;	// res 2,a

	case 0x98:	Res(~Bit3, B);	break;	// res 3,b
	case 0x99:	Res(~Bit3, C);	break;	// res 3,c
	case 0x9a:	Res(~Bit3, D);	break;	// res 3,d
	case 0x9b:	Res(~Bit3, E);	break;	// res 3,e
	case 0x9c:	Res(~Bit3, H);	break;	// res 3,h
	case 0x9d:	Res(~Bit3, L);	break;	// res 3,l
	case 0x9e:	ResHL(~Bit3);	break;	// res 3,(hl)
	case 0x9f:	Res(~Bit3, A);	break;	// res 3,a

	case 0xa0:	Res(~Bit4, B);	break;	// res 4,b
	case 0xa1:	Res(~Bit4, C);	break;	// res 4,c
	case 0xa2:	Res(~Bit4, D);	break;	// res 4,d
	case 0xa3:	Res(~Bit4, E);	break;	// res 4,e
	case 0xa4:	Res(~Bit4, H);	break;	// res 4,h
	case 0xa5:	Res(~Bit4, L);	break;	// res 4,l
	case 0xa6:	ResHL(~Bit4);	break;	// res 4,(hl)
	case 0xa7:	Res(~Bit4, A);	break;	// res 4,a

	case 0xa8:	Res(~Bit5, B);	break;	// res 5,b
	case 0xa9:	Res(~Bit5, C);	break;	// res 5,c
	case 0xaa:	Res(~Bit5, D);	break;	// res 5,d
	case 0xab:	Res(~Bit5, E);	break;	// res 5,e
	case 0xac:	Res(~Bit5, H);	break;	// res 5,h
	case 0xad:	Res(~Bit5, L);	break;	// res 5,l
	case 0xae:	ResHL(~Bit5);	break;	// res 5,(hl)
	case 0xaf:	Res(~Bit5, A);	break;	// res 5,a

	case 0xb0:	Res(~Bit6, B);	break;	// res 6,b
	case 0xb1:	Res(~Bit6, C);	break;	// res 6,c
	case 0xb2:	Res(~Bit6, D);	break;	// res 6,d
	case 0xb3:	Res(~Bit6, E);	break;	// res 6,e
	case 0xb4:	Res(~Bit6, H);	break;	// res 6,h
	case 0xb5:	Res(~Bit6, L);	break;	// res 6,l
	case 0xb6:	ResHL(~Bit6);	break;	// res 6,(hl)
	case 0xb7:	Res(~Bit6, A);	break;	// res 6,a

	case 0xb8:	Res(static_cast<BYTE>(~Bit7), B);	break;	// res 7,b
	case 0xb9:	Res(static_cast<BYTE>(~Bit7), C);	break;	// res 7,c
	case 0xba:	Res(static_cast<BYTE>(~Bit7), D);	break;	// res 7,d
	case 0xbb:	Res(static_cast<BYTE>(~Bit7), E);	break;	// res 7,e
	case 0xbc:	Res(static_cast<BYTE>(~Bit7), H);	break;	// res 7,h
	case 0xbd:	Res(static_cast<BYTE>(~Bit7), L);	break;	// res 7,l
	case 0xbe:	ResHL(static_cast<BYTE>(~Bit7));	break;	// res 7,(hl)
	case 0xbf:	Res(static_cast<BYTE>(~Bit7), A);	break;	// res 7,a

	// SET b, r / SET b,(ixy+d), r
	case 0xc0:	Set(Bit0, B);	break;	// set 0,b
	case 0xc1:	Set(Bit0, C);	break;	// set 0,c
	case 0xc2:	Set(Bit0, D);	break;	// set 0,d
	case 0xc3:	Set(Bit0, E);	break;	// set 0,e
	case 0xc4:	Set(Bit0, H);	break;	// set 0,h
	case 0xc5:	Set(Bit0, L);	break;	// set 0,l
	case 0xc6:	SetHL(Bit0);	break;	// set 0,(hl)
	case 0xc7:	Set(Bit0, A);	break;	// set 0,a

	case 0xc8:	Set(Bit1, B);	break;	// set 1,b
	case 0xc9:	Set(Bit1, C);	break;	// set 1,c
	case 0xca:	Set(Bit1, D);	break;	// set 1,d
	case 0xcb:	Set(Bit1, E);	break;	// set 1,e
	case 0xcc:	Set(Bit1, H);	break;	// set 1,h
	case 0xcd:	Set(Bit1, L);	break;	// set 1,l
	case 0xce:	SetHL(Bit1);	break;	// set 1,(hl)
	case 0xcf:	Set(Bit1, A);	break;	// set 1,a

	case 0xd0:	Set(Bit2, B);	break;	// set 2,b
	case 0xd1:	Set(Bit2, C);	break;	// set 2,c
	case 0xd2:	Set(Bit2, D);	break;	// set 2,d
	case 0xd3:	Set(Bit2, E);	break;	// set 2,e
	case 0xd4:	Set(Bit2, H);	break;	// set 2,h
	case 0xd5:	Set(Bit2, L);	break;	// set 2,l
	case 0xd6:	SetHL(Bit2);	break;	// set 2,(hl)
	case 0xd7:	Set(Bit2, A);	break;	// set 2,a

	case 0xd8:	Set(Bit3, B);	break;	// set 3,b
	case 0xd9:	Set(Bit3, C);	break;	// set 3,c
	case 0xda:	Set(Bit3, D);	break;	// set 3,d
	case 0xdb:	Set(Bit3, E);	break;	// set 3,e
	case 0xdc:	Set(Bit3, H);	break;	// set 3,h
	case 0xdd:	Set(Bit3, L);	break;	// set 3,l
	case 0xde:	SetHL(Bit3);	break;	// set 3,(hl)
	case 0xdf:	Set(Bit3, A);	break;	// set 3,a

	case 0xe0:	Set(Bit4, B);	break;	// set 4,b
	case 0xe1:	Set(Bit4, C);	break;	// set 4,c
	case 0xe2:	Set(Bit4, D);	break;	// set 4,d
	case 0xe3:	Set(Bit4, E);	break;	// set 4,e
	case 0xe4:	Set(Bit4, H);	break;	// set 4,h
	case 0xe5:	Set(Bit4, L);	break;	// set 4,l
	case 0xe6:	SetHL(Bit4);	break;	// set 4,(hl)
	case 0xe7:	Set(Bit4, A);	break;	// set 4,a

	case 0xe8:	Set(Bit5, B);	break;	// set 5,b
	case 0xe9:	Set(Bit5, C);	break;	// set 5,c
	case 0xea:	Set(Bit5, D);	break;	// set 5,d
	case 0xeb:	Set(Bit5, E);	break;	// set 5,e
	case 0xec:	Set(Bit5, H);	break;	// set 5,h
	case 0xed:	Set(Bit5, L);	break;	// set 5,l
	case 0xee:	SetHL(Bit5);	break;	// set 5,(hl)
	case 0xef:	Set(Bit5, A);	break;	// set 5,a

	case 0xf0:	Set(Bit6, B);	break;	// set 6,b
	case 0xf1:	Set(Bit6, C);	break;	// set 6,c
	case 0xf2:	Set(Bit6, D);	break;	// set 6,d
	case 0xf3:	Set(Bit6, E);	break;	// set 6,e
	case 0xf4:	Set(Bit6, H);	break;	// set 6,h
	case 0xf5:	Set(Bit6, L);	break;	// set 6,l
	case 0xf6:	SetHL(Bit6);	break;	// set 6,(hl)
	case 0xf7:	Set(Bit6, A);	break;	// set 6,a

	case 0xf8:	Set(Bit7, B);	break;	// set 7,b
	case 0xf9:	Set(Bit7, C);	break;	// set 7,c
	case 0xfa:	Set(Bit7, D);	break;	// set 7,d
	case 0xfb:	Set(Bit7, E);	break;	// set 7,e
	case 0xfc:	Set(Bit7, H);	break;	// set 7,h
	case 0xfd:	Set(Bit7, L);	break;	// set 7,l
	case 0xfe:	SetHL(Bit7);	break;	// set 7,(hl)
	case 0xff:	Set(Bit7, A);	break;	// set 7,a
	}
}


void Z80::OpED()
{
	_MREQLine = _RDLine = LineLow;
	applyMemoryContention(4, PC);
	BYTE op2 = memoryReadRaw(PC++);
	_MREQLine = _RDLine = LineHigh;
	IncR();
	switch(op2)
	{
	case 0x40:	InC(B);			break;		// in b,(c)
	case 0x41:	OutC(B);		break;		// out (c),b
	case 0x42:	SbcHL(BC);		break;		// sbc hl,bc
	case 0x43:	LdNNRR(BC);		break;		// ld (nn),bc
	case 0x44:	Neg();			break;		// neg
	case 0x45:	Retn();			break;		// retn
	case 0x46:	Im0();			break;		// im 0
	case 0x47:	LdIA();			break;		// ld i,a
	case 0x48:	InC(C);			break;		// in c,(c)
	case 0x49:	OutC(C);		break;		// out (c),c
	case 0x4a:	AdcHL(BC);		break;		// adc hl,bc
	case 0x4b:	LdRRNN(BC);		break;		// ld bc,(nn)
	case 0x4c:	Neg();			break;		// neg *
	case 0x4d:	Reti();			break;		// reti
	case 0x4e:	Im0();			break;		// im 0 *
	case 0x4f:	LdRA();			break;		// ld r,a
	case 0x50:	InC(D);			break;		// in d,(c)
	case 0x51:	OutC(D);		break;		// out (c),d
	case 0x52:	SbcHL(DE);		break;		// sbc hl,de
	case 0x53:	LdNNRR(DE);		break;		// ld (nn),de
	case 0x54:	Neg();			break;		// neg *
	case 0x55:	Retn();			break;		// retn *
	case 0x56:	Im1();			break;		// im 1
	case 0x57:	LdAI();			break;		// ld a,i
	case 0x58:	InC(E);			break;		// in e,(c)
	case 0x59:	OutC(E);		break;		// out (c),e
	case 0x5a:	AdcHL(DE);		break;		// adc hl,de
	case 0x5b:	LdRRNN(DE);		break;		// ld de,(nn)
	case 0x5c:	Neg();			break;		// neg *
	case 0x5d:	Retn();			break;		// retn *
	case 0x5e:	Im2();			break;		// im 2
	case 0x5f:	LdAR();			break;		// ld a,r
	case 0x60:	InC(H);			break;		// in h,(c)
	case 0x61:	OutC(H);		break;		// out (c),h
	case 0x62:	SbcHL(HL);		break;		// sbc hl,hl
	case 0x63:	LdNNRR(HL);		break;		// ld (nn),hl
	case 0x64:	Neg();			break;		// neg *
	case 0x65:	Retn();			break;		// retn *
	case 0x66:	Im0();			break;		// im 0 *
	case 0x67:	Rrd();			break;		// rrd
	case 0x68:	InC(L);			break;		// in l,(c)
	case 0x69:	OutC(L);		break;		// out (c),l
	case 0x6a:	AdcHL(HL);		break;		// adc hl,hl
	case 0x6b:	LdRRNN(HL);		break;		// ld hl,(nn)
	case 0x6c:	Neg();			break;		// neg *
	case 0x6d:	Retn();			break;		// retn *
	case 0x6e:	Im0();			break;		// im 0 *
	case 0x6f:	Rld();			break;		// rld
	case 0x70:	InCF();			break;		// in (c) doesn't store result anywhere *
	case 0x71:	OutC(0);		break;		// out (c),0 *
	case 0x72:	SbcHL(SP);		break;		// sbc hl,sp
	case 0x73:	LdNNRR(SP);		break;		// ld (nn),sp
	case 0x74:	Neg();			break;		// neg *
	case 0x75:	Retn();			break;		// retn *
	case 0x76:	Im1();			break;		// im 1
	case 0x77:	EDNop(op2);		break;		// nop *
	case 0x78:	InC(A);			break;		// in a,(c)
	case 0x79:	OutC(A);		break;		// out (c),a
	case 0x7a:	AdcHL(SP);		break;		// adc hl,sp
	case 0x7b:	LdRRNN(SP);		break;		// ld sp,(nn)
	case 0x7c:	Neg();			break;		// neg *
	case 0x7d:	Retn();			break;		// retn *
	case 0x7e:	Im2();			break;		// im 2 *

	case 0xa0:	Ldi();			break;		// ldi
	case 0xa1:	Cpi();			break;		// cpi
	case 0xa2:	Ini();			break;		// ini
	case 0xa3:	Outi();			break;		// outi

	case 0xa8:	Ldd();			break;		// ldd
	case 0xa9:	Cpd();			break;		// cpd
	case 0xaa:	Ind();			break;		// ind
	case 0xab:	Outd();			break;		// outd

	case 0xb0:	Ldir();			break;		// ldir
	case 0xb1:	Cpir();			break;		// cpir
	case 0xb2:	Inir();			break;		// inir
	case 0xb3:	Otir();			break;		// otir

	case 0xb8:	Lddr();			break;		// lddr
	case 0xb9:	Cpdr();			break;		// cpdr
	case 0xba:	Indr();			break;		// indr
	case 0xbb:	Otdr();			break;		// otdr

	default:	EDNop(op2);		break;
	}
}


const std::string &	Z80::getVersionString()
{
	return InkZ80VersionStr;
}


//
// Breakpoints
//


bool Z80::GetBreakpoint(size_t idx, Z80Breakpoint & brk) const
{
	if (idx < m_breakpoints.size())
	{
		brk = m_breakpoints[idx];
		return true;
	}
	return false;
}


void Z80::RefreshBreakpointBitmap()
{
	unsigned bitmap = 0;
	for (auto const & b : m_breakpoints)
	{
		if (b.enabled)
			bitmap |= b.type;
	}
	m_enabledBreakpointTypeBitmap = bitmap;
}


void Z80::MakeBreakpointAddressSet(Z80BreakpointType type, std::set<WORD> & brkMap) const
{
	for(auto const & b : m_breakpoints)
	{
		if (b.type & type)
			brkMap.insert(b.address);
	}
}


unsigned Z80::AddBreakpoint(const Z80Breakpoint & brk)
{
	Z80Breakpoint bp(brk);
	bp.id = m_breakpointIdSeed++;
	bp.instructionCountWhenHit = -1;		// Not been hit yet
	m_breakpoints.push_back(bp);

	RefreshBreakpointBitmap();
	return bp.id;
}


bool Z80::UpdateBreakpoint(const Z80Breakpoint & brk)
{
	for (auto & b : m_breakpoints)
	{
		if (b.id == brk.id)
		{
			b.type = brk.type;
			b.address = brk.address;
			b.addressMask = brk.addressMask;
			b.enabled = brk.enabled;
			b.oneShot = brk.oneShot;
			b.userData = brk.userData;
			b.condition = brk.condition;
			b.hitCount = brk.hitCount;
			b.hitCountMode = brk.hitCountMode;
			b.hitCountParam = brk.hitCountParam;
			return true;
		}
	}
	return false;
}


bool Z80::DeleteBreakpoint(unsigned id)
{
	auto i = m_breakpoints.begin();
	while (i != m_breakpoints.end())
	{
		if (i->id == id)
		{
			m_breakpoints.erase(i);
			return true;
		}
		++i;
	}
	return false;
}


bool Z80::FindBreakpoint(unsigned id, Z80Breakpoint & brk) const
{
	// Only go hunting for a matching breakpoint type if we know there is at least one
	auto it = m_breakpoints.begin();
	while (it != m_breakpoints.end())
	{
		if (it->id == id)
		{
			brk = *it;
			return true;
		}
		++it;
	}
	return false;
}


bool Z80::FindBreakpointFromType(Z80BreakpointType type, WORD address, Z80Breakpoint & brk) const
{
	// Only go hunting for a matching breakpoint type if we know there is at least one
	if (m_enabledBreakpointTypeBitmap & type)
	{
		auto it = m_breakpoints.begin();
		while (it != m_breakpoints.end())
		{
			if (it->type == type && it->address == address)
			{
				brk = *it;
				return true;
			}
			++it;
		}
	}
	return false;
}


void Z80::DeleteBreakpointsOfType(Z80BreakpointType type)
{
	auto i = m_breakpoints.begin();
	while (i != m_breakpoints.end())
	{
		if (type == i->type)
			i = m_breakpoints.erase(i);
		else
			++i;
	}
	RefreshBreakpointBitmap();
	return;
}


void Z80::DeleteAllBreakpoints(bool includeHidden)
{
	auto it = m_breakpoints.begin();
	while (it != m_breakpoints.end())
	{
		if (includeHidden || it->hidden == false)
			it = m_breakpoints.erase(it);
		else
			++it;
	}
	RefreshBreakpointBitmap();
}


bool Z80::DoHitBreakpoint(Z80Breakpoint & bp)
{
	// If this breakpoint has a condition attached to it, evaluate it now and return
	// unless it evaluates to true
	if (bp.HasCondition())
	{
		if (TestBreakpointCondition(bp) == false)
			return false;
	}

	// HitCount?
	bp.hitCount++;
	bool hitApplies = true;
	switch(bp.hitCountMode)
	{
		case Z80BreakpointHitMode::WhenEqual:
			hitApplies = bp.hitCount == bp.hitCountParam;
			break;

		case Z80BreakpointHitMode::WhenGreaterOrEqual:
			hitApplies = bp.hitCount >= bp.hitCountParam;
			break;

		case Z80BreakpointHitMode::WhenMultipleOf:
			if (bp.hitCountParam)
				hitApplies = (bp.hitCount % bp.hitCountParam) == 0;
			break;
		case Z80BreakpointHitMode::Always:
			break;
	}

	if (!hitApplies)
		return false;
	
	// Bingo!
	m_executionState = XSBreakpointHit;
	m_breakpointTypeHit = bp.type;
	m_breakpointIdHit = bp.id;
	bp.instructionCountWhenHit = _numInstructionsExecuted;

	// If a one-shot breakpoint, delete it now
	if (bp.oneShot)
	{
		auto it = std::find_if(m_breakpoints.begin(), m_breakpoints.end(), [&](const Z80Breakpoint & fbp) 
		{
			return fbp.id == bp.id;
		});
		assert(it != m_breakpoints.end());
		if (it != m_breakpoints.end())
			m_breakpoints.erase(it);
		RefreshBreakpointBitmap();
	}

	return true;
}


bool Z80::TestHitBreakpoint(Z80BreakpointType type)
{
	// Only go hunting for a matching breakpoint type if we know there is at least one
	if (m_enabledBreakpointTypeBitmap & type)
	{
		auto it = m_breakpoints.begin();
		while (it != m_breakpoints.end())
		{
			if (it->enabled && it->type == type)
				return DoHitBreakpoint(*it);

			++it;
		}
	}
	return false;
}


inline bool Z80::TestHitBreakpoint(Z80BreakpointType type, WORD address)
{
	// Only go hunting for a matching breakpoint type if we know there is at least one
	if (m_enabledBreakpointTypeBitmap & type)
	{
		auto it = m_breakpoints.begin();
		while (it != m_breakpoints.end())
		{
			if (it->enabled && ((it->type & type) != 0) && (it->address == (address & it->addressMask)))
			{
				// If we've already landed on this breakpoint, let us move off it, so don't regard as a hit
				if (it->instructionCountWhenHit == _numInstructionsExecuted)
					return false;

				return DoHitBreakpoint(*it);
			}
			++it;
		}
	}
	return false;
}


void Z80::SetRCountdown(int rChanges)
{
	assert(rChanges >= 0);
	_RCountRemaining = rChanges;
}


// static
bool Z80::IsBreakpointFieldUsedByType(Z80BreakpointType type, Z80BreakpointField field)
{
	switch(field)
	{
	case BreakpointFieldType:
	case BreakpointFieldId:
	case BreakpointFieldHitCount:
	case BreakpointFieldHitInstructionCountWhenHit:
	case BreakpointFieldUserData:
	case BreakpointFieldEnabled:
	case BreakpointFieldOneShot:
		return true;

	case BreakpointFieldAddress:
	case BreakpointFieldAddressMask:
		return (type & (BreakpointOpcodeRead | BreakpointMemoryReadWrite | BreakpointPortReadWrite)) != 0;

	default:
		assert(false);
		break;
	}

	return false;
}

